#!/usr/bin/env bash

# You can use this to parse version strings and then use the resulting number for comparison
# Example:
#     if [[ $(parse_version_string $(git --version | grep -E -o "\d+\.\d+.\d+$")) -ge $(parse_version_string "2.39.0") ]]
# https://stackoverflow.com/a/37939589/11447682
function parse_version_string { echo "$@" | awk -F. '{ printf("%d%03d%03d%03d\n", $1,$2,$3,$4); }'; }

get_shell_type() {
	if [[ -n "$ZSH_VERSION" ]]; then
		echo "ZSH"
		return
	elif [[ -n "$BASH_VERSION" ]]; then
		echo "BASH"
	fi
}

reload() {
	shell_type=$(get_shell_type)
	if [[ $shell_type == "ZSH" ]]; then
		source ~/.zshrc
	elif [[ $shell_type == "BASH"  ]]; then
		echo "@TODO"
	else
		echo "Not sure how to reload this shell"
	fi
}

# Like `touch` + `mkdir -p`: creates intermediate directories if they don't exist yet
make-file() {
	file_path=$1
	if [[ -e $file_path ]]; then
		echo "File already exists"
	else
		mkdir -p "$(dirname "$file_path")"
		touch "$file_path"
	fi
}

# Revert the last commit, but don't undo the changes
git_revert_last() {
	git reset HEAD~1
}

git_sha() {
	short=$(git rev-parse --short HEAD)
	long=$(git rev-parse HEAD)
	echo "${short}\t${long}"
}

make_venv() {
	VENV_PATH=./.venv
	echo "Where should the virtual environment be created? (press enter to default to .venv)"
	read -r INPUT
	if [[ $INPUT != "" ]]; then
		VENV_PATH=$INPUT
	fi
	if [[ -d $VENV_PATH ]]; then
		echo "${VENV_PATH} already exists"
	else
		echo "Preparing virtual environment in ${VENV_PATH}"
		python3 -m venv $VENV_PATH
		source $VENV_PATH/bin/activate
	fi
}

# Search for, and activate, a local python virtual environment
# @TODO - if python env is *already* activated, check if path matches, and if not
# 	deactivate and then activate
# @TODO - handle Poetry
activate() {
	fail=1
	possible_envs=(./venv ./.venv ./env ./.env)
	for env_dir in "${possible_envs[@]}"; do
		if [[ -e "$env_dir/bin/activate" ]]; then
			source "$env_dir/bin/activate"
			fail=0
			break
		fi
	done
	return $fail
}

pip_upgrade() {
	python3 -m pip install --upgrade pip
}

# Like clear, but better :)
wipe() {
	for run in {1..10}; do
		echo $'\n'
	done
	clear
}

# Note: This is ZSH specific; todo - make agnostic?
reload_func() {
	unfunction "_$1" && compinit
}

git_branch_backup() {
	current_branch_name=$(git rev-parse --abbrev-ref HEAD)
	backup_branch_name="backup/$current_branch_name--$(date '+%Y-%m-%d--%I-%M-%p')"
	git branch "$backup_branch_name"
	echo "âœ… Backed up branch to $backup_branch_name"
}

git_checkout_dirty() {
	target_branch_name=$1
	operation="git checkout $target_branch_name"
	git_do_while_dirty "$operation"
}

git_do_while_dirty() {
	IFS=
	git_operation=$1
	git_operation_results=$($SHELL -c "$git_operation" 2>&1)

	# If checkout was clean, nothing to do
	error_string_test=$(echo "$git_operation_results" | grep -E "error: Your local changes to the following files would be overwritten by checkout")

	echo "$error_string_test"
	if [[ "$error_string_test" == "" ]]; then
		echo "Checkout was clean"
		return 0
	fi

	# Get list of conflicting file paths
	dirty_files=$(echo "$git_operation_results" | grep -E -o "^[[:blank:]]+.*" | sed -e 's/^[[:space:]]*//')
	cat << EOF
========= DIRTY FILES =========
$dirty_files
===============================
EOF

	# Use stash to temporarily stash changes
	# Newer versions of git can support stashing just staged changes
	use_staged_stash=false
	git_version=$(git --version | grep -E -o "\d+\.\d+.\d+$")
	if [[ $(parse_version_string "$git_version") -ge $(parse_version_string "2.35") ]]; then

		echo "Found git version >= 2.35"

		# TODO: A future improvement could be asking about this on a per-file basis
		# I.e., go through list of dirty files and ask "[Dd]rop? [Ss]tash and pop? [Cc]ancel?"
		while true; do
			printf "Your git version supports staged stashes. Use feature? [Yy]es / ENTER, [Nn]o, [Cc]ancel\n"
			read -r answer
			case $answer in
				[Yy]* ) use_staged_stash=true && break;;
				"" ) use_staged_stash=true && break;;
				[Nn]* ) use_staged_stash=false && break;;
				[Cc]* ) return 0;;
			esac
		done
	else
		while true; do
			printf "Your git version does NOT support staged stashes. Continue? [Yy]es / ENTER, [Nn]o, [Cc]ancel\n"
			read -r answer
			case $answer in
				[Yy]* ) break;;
				"" ) break;;
				[Nn]* ) return 0;;
				[Cc]* ) return 0;;
			esac
		done
	fi

	preserve="unsure"
	# different fd (`<&9`) is to avoid conflict with inner `read`
	# https://stackoverflow.com/q/6911520/11447682
	while IFS= read -r dirty_file <&9; do
		if [[ $preserve == "unsure" ]]; then
			while true; do
				# Ask user what to do about this (and rest) of files
				printf "Keep changes to %s?\n" "$dirty_file"
				printf "[Aa]ll files, [Yy]es / ENTER, [Nn]o, / [Dd]rop+rest, [Cc]ancel\n"
				read -r answer
				case $answer in
					[Aa]* ) preserve="all" && break;;
					[Yy]* ) preserve="yes" && break;;
					"" ) break;;
					[Nn]* ) preserve="no" && break;;
					[Dd]* ) preserve="none" && break;;
					[Cc]* ) return 0;;
				esac
			done
		fi

		if [[ $preserve == "none" ]]; then
			git checkout "$dirty_file"
		elif [[ $preserve == "all" ]]; then
			git add "$dirty_file"
		else
			if [[ $preserve == "yes" ]]; then
				git add "$dirty_file"
			else
				git checkout "$dirty_file"
			fi
			# Reset for next go-around
			preserve="unsure"
		fi
	done 9<<< "$dirty_files"

	if [[ $use_staged_stash == "true" ]]; then
		git stash --staged
	else
		git stash
	fi
	$SHELL -c "$git_operation"
	git stash pop
}
