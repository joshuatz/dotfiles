#!/usr/bin/env bash

get_shell_type() {
	if [[ -n "$ZSH_VERSION" ]] || echo $SHELL | grep --silent -E "\/zsh$"; then
		echo "ZSH"
		return
	elif [[ -n "$BASH_VERSION" ]] || echo $SHELL | grep --silent -E "\/bash$"; then
		echo "BASH"
	fi
}
SHELL_TYPE=$(get_shell_type)

# You can use this to parse version strings and then use the resulting number for comparison
# Example:
#     if [[ $(parse_version_string $(git --version | grep -E -o "\d+\.\d+.\d+$")) -ge $(parse_version_string "2.39.0") ]]
# https://stackoverflow.com/a/37939589/11447682
function parse_version_string { echo "$@" | awk -F. '{ printf("%d%03d%03d%03d\n", $1,$2,$3,$4); }'; }

reload() {
	if [[ $SHELL_TYPE == "ZSH" ]]; then
		# Note: Don't use source ~/.zshrc
		# See: https://github.com/ohmyzsh/ohmyzsh/wiki/FAQ#how-do-i-reload-the-zshrc-file
		exec zsh
	elif [[ $SHELL_TYPE == "BASH"  ]]; then
		source ~/.bash_profile
	else
		echo "Not sure how to reload this shell"
	fi
}

# Like `touch` + `mkdir -p`: creates intermediate directories if they don't exist yet
make-file() {
	file_path=$1
	if [[ -e $file_path ]]; then
		echo "File already exists"
	else
		mkdir -p "$(dirname "$file_path")"
		touch "$file_path"
	fi
}

# Revert the last commit, but don't undo the changes
git_revert_last() {
	git reset HEAD~1
}

git_sha() {
	short=$(git rev-parse --short HEAD)
	long=$(git rev-parse HEAD)
	echo "${short}\t${long}"
}

git_behind_ahead() {
	# Get the trunk / main branch in the repo (e.g. `main`)
	TRUNK_BRANCH=$(git remote show origin | grep "HEAD branch" | cut -d ":" -f 2 | sed -e 's/^[[:space:]]*//')
	echo "Behind | Ahead"
	echo "      $(git rev-list --left-right --count origin/"$TRUNK_BRANCH"...HEAD)"
}

make_venv() {
	VENV_PATH=./.venv
	echo "Where should the virtual environment be created? (press enter to default to .venv)"
	read -r INPUT
	if [[ $INPUT != "" ]]; then
		VENV_PATH=$INPUT
	fi
	if [[ -d $VENV_PATH ]]; then
		echo "${VENV_PATH} already exists"
	else
		echo "Preparing virtual environment in ${VENV_PATH}"
		python3 -m venv $VENV_PATH
		source $VENV_PATH/bin/activate
	fi
}

check_venv() {
	which python | grep "$PWD"
}

# Generates the poetry named environment string
# Although this _can_ be used to check that the correct virtual environment is
# activated, it is generally much easier to just use a regular venv and point
# poetry to it (because then you can just do something like `which python | grep $PWD`)
# For implementation reference see
#   https://github.com/python-poetry/poetry/blob/7c86992909257caa4f51a50c001f5894bfe5065e/src/poetry/utils/env.py#L635
#   https://github.com/python-poetry/poetry/blob/7c86992909257caa4f51a50c001f5894bfe5065e/src/poetry/utils/env.py#L1212-L1220
generate_poetry_env_name_str() {
	PROJECT_NAME=$(basename "$PWD")
	if [[ -f pyproject.toml ]]; then
		PROJECT_NAME=$(poetry version | sed -E -n 's/(.+) [.0-9]+$/\1/p')
	fi
	PROJECT_NAME=$PROJECT_NAME python << "EOF"
import base64
import os
import re
import hashlib

# shim - re-implement poetry encode method
def encode(string: str):
	if isinstance(string, bytes):
		return string
	return string.encode("utf-8")

def generate_env_name(package_name: str, cwd: str) -> str:
	package_name = package_name.lower()
	sanitized_name = re.sub(r'[ $`!*@"\\\r\n\t]', "_", package_name)[:42]
	normalized_cwd = os.path.normcase(os.path.realpath(cwd))
	h_bytes = hashlib.sha256(encode(normalized_cwd)).digest()
	h_str = base64.urlsafe_b64encode(h_bytes).decode()[:8]
	return f"{sanitized_name}-{h_str}"

cwd = os.getcwd()
print(generate_env_name(os.environ["PROJECT_NAME"], cwd))
# Should print something like `project-name-ABCD1a-Z`
EOF
}

# Search for, and activate, a local python virtual environment
# @TODO - if python env is *already* activated, check if path matches, and if not
# 	deactivate and then activate
# @TODO - handle Poetry
activate() {
	fail=1
	possible_envs=(./venv ./.venv ./env ./.env)
	for env_dir in "${possible_envs[@]}"; do
		if [[ -e "$env_dir/bin/activate" ]]; then
			source "$env_dir/bin/activate"
			fail=0
			break
		fi
	done
	return $fail
}

pip_upgrade() {
	python3 -m pip install --upgrade pip
}

# Like clear, but extra space to pad the start
wipe() {
	for run in {1..10}; do
		echo $'\n'
	done
	clear
}

# Note: This is ZSH specific; todo - make agnostic?
reload_func() {
	unfunction "_$1" && compinit
}

git_branch_backup() {
	current_branch_name=$(git rev-parse --abbrev-ref HEAD)
	backup_branch_name="backup/$current_branch_name--$(date '+%Y-%m-%d--%I-%M-%p')"
	git branch "$backup_branch_name"
	echo "âœ… Backed up branch to $backup_branch_name"
}

git_checkout_dirty() {
	target_branch_name=$1
	operation="git checkout $target_branch_name"
	git_do_while_dirty "$operation"
}
if [[ $SHELL_TYPE == "ZSH" ]]; then
	:
	# TODO: This is close, but not working perfectly
	# compdef _git git_checkout_dirty=git-checkout
fi

git_do_while_dirty() {
	IFS=
	git_operation=$1

	# If user forgot to include `git`, add it for them. E.g., passing `pull` instead of `git pull`
	if [[ $git_operation != git* ]]; then
		git_operation="git $git_operation"
	fi

	# Error out when command is NOT run from root of git repo, as this can cause issues with things
	# like `git checkout ${PATHSPEC}`, as the paths git's stdout uses are relative to repo root,
	# even if you running command from subdirectory
	git_root=$(git rev-parse --show-toplevel)
	if [[ "$git_root" != "$PWD" ]]; then
		echo "ERROR: You are not running this command from the root of a git repository"
		echo "This can cause issues with things like \`git checkout\`, as the paths git's stdout"
		echo "uses are relative to repo root, even if you running command from subdirectory"
		echo "Current directory: $PWD"
		echo "Git root: $git_root"
		return 1
	fi

	git_operation_results=$($SHELL -c "$git_operation" 2>&1)

	# If operation was clean, nothing to do
	error_string_test=$(echo "$git_operation_results" | grep -E "error: Your local changes to the following files would be overwritten by")

	echo "$error_string_test"
	if [[ "$error_string_test" == "" ]]; then
		echo "Operation was clean"
		return 0
	fi

	# Get list of conflicting file paths
	dirty_files=$(echo "$git_operation_results" | grep -E -o "^[[:blank:]]+.*" | sed -e 's/^[[:space:]]*//')
	cat << EOF
========= DIRTY FILES =========
$dirty_files
===============================
EOF

	# Use stash to temporarily stash changes
	# Newer versions of git can support stashing just staged changes
	use_staged_stash=false
	git_version=$(git --version | grep -E -o "\d+\.\d+.\d+$")
	if [[ $(parse_version_string "$git_version") -ge $(parse_version_string "2.35") ]]; then
		echo "Found git version >= 2.3"
		echo "Your git version supports staged stashes."
		use_staged_stash=true
	else
		while true; do
			printf "Your git version does NOT support staged stashes. Continue? [Yy]es / ENTER, [Nn]o, [Cc]ancel\n"
			read -r answer
			case $answer in
				[Yy]* ) break;;
				"" ) break;;
				[Nn]* ) return 0;;
				[Cc]* ) return 0;;
			esac
		done
	fi

	# Go through list of conflicting files and ask what the user wants to do
	preserve="unsure"
	# different fd (`<&9`) is to avoid conflict with inner `read`
	# https://stackoverflow.com/q/6911520/11447682
	while IFS= read -r dirty_file <&9; do
		if [[ $preserve == "unsure" ]]; then
			while true; do
				# Ask user what to do about this (and rest) of files
				printf "Keep changes to %s?\n" "$dirty_file"
				printf "[Aa]ll files, [Yy]es / ENTER, [Nn]o, / [Dd]rop+rest, [Pp]review, [Cc]ancel\n"
				read -r answer
				case $answer in
					[Aa]* ) preserve="all" && break;;
					[Yy]* ) preserve="yes" && break;;
					"" ) break;;
					[Nn]* ) preserve="no" && break;;
					[Dd]* ) preserve="none" && break;;
					[Pp]* ) git diff "$dirty_file";;
					[Cc]* ) return 0;;
				esac
			done
		fi

		if [[ $preserve == "none" ]]; then
			git checkout "$dirty_file"
		elif [[ $preserve == "all" ]]; then
			git add "$dirty_file"
		else
			if [[ $preserve == "yes" ]]; then
				git add "$dirty_file"
			else
				git checkout "$dirty_file"
			fi
			# Reset for next go-around
			preserve="unsure"
		fi
	done 9<<< "$dirty_files"

	if [[ $use_staged_stash == "true" ]]; then
		git stash --staged
	else
		git stash
	fi
	$SHELL -c "$git_operation"
	git stash pop
}

get_docker_working_dir() {
	CONTAINER_REF=$1
	docker inspect --format='{{json .Config.Labels}}' "$CONTAINER_REF" | jq '.["com.docker.compose.project.working_dir"]'
}


# This is currently pretty macoS specific
# Also, runs code that triggers OS permission checks, so will fail if denied
whats_up() {
	WINDOW_TITLE=$(cat << "EOF" | xargs -0 osascript -e
global frontApp, frontAppName, windowTitle

set windowTitle to ""
tell application "System Events"
	set frontApp to first application process whose frontmost is true
	set frontAppName to name of frontApp
	tell process frontAppName
		tell (1st window whose value of attribute "AXMain" is true)
			set windowTitle to value of attribute "AXTitle"
		end tell
	end tell
end tell

return {frontAppName, windowTitle}
EOF
)
	cat << EOF
Active Window = $WINDOW_TITLE
EOF

	if (which jttu > /dev/null); then
		printf '==== Time Tracker ====\n'
		jttu harvest status
		printf '======================'
	fi
}
