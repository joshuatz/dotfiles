#!/usr/bin/env bash

# You can use this to parse version strings and then use the resulting number for comparison
# Example:
#     if [[ $(parse_version_string $(git --version | grep -E -o "\d+\.\d+.\d+$")) -ge $(parse_version_string "2.39.0") ]]
# https://stackoverflow.com/a/37939589/11447682
function parse_version_string { echo "$@" | awk -F. '{ printf("%d%03d%03d%03d\n", $1,$2,$3,$4); }'; }

get_shell_type() {
	if [[ -n "$ZSH_VERSION" ]]; then
		echo "ZSH"
		return
	elif [[ -n "$BASH_VERSION" ]]; then
		echo "BASH"
	fi
}

reload() {
	shell_type=$(get_shell_type)
	if [[ $shell_type == "ZSH" ]]; then
		source ~/.zshrc
	elif [[ $shell_type == "BASH"  ]]; then
		echo "@TODO"
	else
		echo "Not sure how to reload this shell"
	fi
}

# Like `touch` + `mkdir -p`: creates intermediate directories if they don't exist yet
make-file() {
	file_path=$1
	if [[ -e $file_path ]]; then
		echo "File already exists"
	else
		mkdir -p "$(dirname "$file_path")"
		touch "$file_path"
	fi
}

# Revert the last commit, but don't undo the changes
git_revert_last() {
	git reset HEAD~1
}

git_sha() {
	short=$(git rev-parse --short HEAD)
	long=$(git rev-parse HEAD)
	echo "${short}\t${long}"
}

make_venv() {
	VENV_PATH=./.venv
	echo "Where should the virtual environment be created? (press enter to default to .venv)"
	read -r INPUT
	if [[ $INPUT != "" ]]; then
		VENV_PATH=$INPUT
	fi
	if [[ -d $VENV_PATH ]]; then
		echo "${VENV_PATH} already exists"
	else
		echo "Preparing virtual environment in ${VENV_PATH}"
		python3 -m venv $VENV_PATH
		source $VENV_PATH/bin/activate
	fi
}

# Search for, and activate, a local python virtual environment
# @TODO - if python env is *already* activated, check if path matches, and if not
# 	deactivate and then activate
# @TODO - handle Poetry
activate() {
	fail=1
	possible_envs=(./venv ./.venv ./env ./.env)
	for env_dir in "${possible_envs[@]}"; do
		if [[ -e "$env_dir/bin/activate" ]]; then
			source "$env_dir/bin/activate"
			fail=0
			break
		fi
	done
	return $fail
}

pip_upgrade() {
	python3 -m pip install --upgrade pip
}

# Like clear, but better :)
wipe() {
	for run in {1..10}; do
		echo $'\n'
	done
	clear
}

# Note: This is ZSH specific; todo - make agnostic?
reload_func() {
	unfunction "_$1" && compinit
}
